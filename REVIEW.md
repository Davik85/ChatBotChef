# ChatBotChef — технический обзор

## 1. Общая готовность
- Приложение стартует с проверки обязательных токенов и логгирует только факт наличия, что полезно для эксплуатации, но при отсутствии `PROVIDER_TOKEN` оно упадёт уже при первом обращении к оплате из-за `require` в `AppConfig`, хотя бот может работать и без платёжного сценария. Рекомендация — сделать токен опциональным и возвращать дружелюбное сообщение, если платёж временно недоступен.【F:src/main/kotlin/app/AppConfig.kt†L39-L65】【F:src/main/kotlin/app/web/TelegramLongPolling.kt†L114-L165】
- Стоит внедрить отдельный обработчик платёжных исключений, который будет валидировать запросы Telegram (подпись, валюту, amount) и отвечать пользователю дружелюбно, не раскрывая внутренние детали. Сейчас обработка платежей происходит в тех же корутинах, что и остальная логика, и при ошибке бот просто выдаст stack trace в лог. Добавьте проверку `preCheckoutQuery` и логику подтверждения платежа с валидацией суммы, а также централизованно логируйте транзакции для расследования инцидентов.【F:src/main/kotlin/app/web/TelegramLongPolling.kt†L166-L224】
- Инициализация базы содержит продуманные миграции и гарантирует создание директорий/индексов. Тем не менее, отсутствуют smoke-тесты миграций и health-checkа SQLite, что усложнит CI/CD. Стоит добавить интеграционные тесты или хотя бы отдельную команду для проверки схемы при деплое.【F:src/main/kotlin/app/db/DatabaseFactory.kt†L1-L206】

## 2. Безопасность
- Секреты не логируются, токены маскируются, что соответствует best practices. Однако Telegram-команды администрирования определяются только через список ID из переменной окружения без дополнительной аутентификации; важно убедиться, что переменная заполнена на всех окружениях, иначе команды будут доступны владельцу чата по умолчанию.【F:src/main/kotlin/app/Main.kt†L12-L49】【F:src/main/kotlin/app/web/TelegramLongPolling.kt†L38-L120】
- Контент-фильтрация минимальна: `Safety` проверяет лишь несколько ключевых слов, а результаты проверок нигде не используются перед отправкой запросов в LLM или ответов пользователю. Это создаёт риски выдачи токсичного или запрещённого контента. Рекомендация — интегрировать проверку `Safety` в маршрутизацию и добавлять более полноценные фильтры или модерацию OpenAI.【F:src/main/kotlin/app/logic/Safety.kt†L1-L19】【F:src/main/kotlin/app/web/TelegramLongPolling.kt†L166-L224】
- В платёжных сценариях не хватает мер по защите от повторных оплат и проверки статуса, полученного от Telegram. Рекомендуется хранить идентификаторы заказов и статусы в базе, чтобы детектировать дубли, а также предусмотреть таймаут подтверждения и уведомление пользователя при сбое. Это снизит риск двойного списания и упростит reconciliation с провайдером. Дополнительно добавьте алерты при увеличении доли отклонённых оплат и логируйте причину отказа для поддержки.【F:src/main/kotlin/app/web/TelegramLongPolling.kt†L166-L224】【F:src/main/kotlin/app/db/DatabaseFactory.kt†L1-L206】
- Все вызовы Telegram API идут с `parse_mode="Markdown"`, что даёт возможность пользователям поломать сообщение управляющими символами. Стоит либо экранировать пользовательский ввод, либо отправлять в `MarkdownV2`/plain text. Особенно актуально, когда бот пересылает текст, собранный из пользовательских данных (например, в калькуляторе калорий).【F:src/main/kotlin/app/web/TelegramApi.kt†L39-L76】【F:src/main/kotlin/app/web/TelegramLongPolling.kt†L205-L248】

## 3. Производительность и устойчивость
- RateLimiter хранит состояние в памяти. После рестарта сервиса лимиты сбрасываются, что может позволить злоупотребления. Для production-окружения стоит рассмотреть персистентное хранилище (SQLite) или Redis с TTL, чтобы лимиты переживали рестарт.【F:src/main/kotlin/app/logic/RateLimiter.kt†L1-L42】
- В `OpenAIClient.complete` отсутствует повтор запросов при сетевых ошибках и нет логирования исключений (кроме HTTP-кода). Это может приводить к повышенному количеству fallback-ответов. Рекомендация — добавить retry с экспоненциальной паузой и расширенное логирование для диагностики.【F:src/main/kotlin/app/llm/OpenAIClient.kt†L16-L67】
- `TelegramLongPolling` обрабатывает обновления последовательно. При большом количестве пользователей ответ может замедляться, так как сетевые вызовы (`sendMessage`, `complete`) выполняются поочерёдно. Стоит рассмотреть распараллеливание обработки сообщений или вынесение LLM-запросов в корутины с ограниченным пулом.【F:src/main/kotlin/app/web/TelegramLongPolling.kt†L60-L224】

## 4. Дополнительные рекомендации
- Добавить мониторинг health-checkов OpenAI и Telegram (например, метрики Prometheus) для быстрого обнаружения деградаций. Сейчас ошибки только логируются в stdout.【F:src/main/kotlin/app/Main.kt†L30-L47】【F:src/main/kotlin/app/llm/OpenAIClient.kt†L32-L67】
- Документировать необходимые переменные окружения и сценарии запуска (README отсутствует). Это упростит onboarding и инфраструктурную автоматизацию.

В целом код чистый и хорошо структурирован, но требует усиления контентной безопасности, устойчивости к сбоям внешних API и более мягкой обработки опциональных платёжных функций.
